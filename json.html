<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>JSON</title>
</head>

<body>
    <script type="text/javascript">
        // JSON,JavaScript对象表示法，是JavaScript的一个严格的子集，利用了JavaScript中的一些模式来表示结构化数据
        // JSON的媒体MIME类型是application/json

        // JSON不支持对象，函数或对象实例，它是一种表示结构化数据的格式

        // JSON字符串必须使用双引号
        // JSON中对象属性也要加双引号

        // JSON对值的类型和格式有严格的规定
        // 复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。数组是尽量保持数组中的元素是同一类型，JavaScript
        // 支持数组元素类型不同，但其他平台不一定支持，所以保持一致性可以保证JSON的可移植性
        // 简单类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和
        // undefined），简单类型的值除字符串外其它不用双引号包裹
        // 字符串必须使用双引号表示，不能使用单引号
        // 属性命名采用驼峰式
        // 对象的键名必须放在双引号里面。
        // 数组或对象最后一个成员的后面，不能加逗号

        // JSON使用反斜杠\转义
        // JSON值中需要转义的部分：引号中的引号，反斜线\，正斜线/，退格符\b，换页符\f，制表符\t，换行符\n，回车符\r，十六进制符\u

        // JSON对象的两个方法
        // stringify()将JavaScript对象序列化为JSON字符串,在序列化JavaScript对象时，所有函数及其原型成员都会被忽略，
        // 值为undefined的任何属性也都会被跳过，成员的值是undefined、函数或 XML 对象，这个成员会被过滤
        var book = {
            title: "Professional JavaScript",
            authors: [
                "Nicholas C.Zakas"
            ],
            edition: 3,
            year: 2011,
        };
        var jsonText = JSON.stringify(book);
        // JSON.stringify方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性
        console.log(JSON.stringify(book, ["title", "edition"]));
        // 第二个参数还可以是一个函数，用来更改JSON.stringify的默认行为
        console.log(JSON.stringify(book, function (key, value) {
            switch (key) {
                case "authors":
                    return value.join(',')
                    break;
                case "year":
                    return 5000;
                    break;
                case "edition":
                    return undefined; // undefined的值转化为JSON会被忽略
                    break;
                default:
                    return value;
            }
        }), 4); // 数值4作为最后一个参数表示缩进的空格数
        
        // parse()把JSON字符串解析为原生JavaScript值
        console.log(JSON.parse(jsonText));

        // toJSON(),返回其自身的JSON数据格式，可以作为函数过滤器的补充
        // 普通对象转化JSON
        var user = {
            firstName: '三',
            lastName: '张',
            get fullName() {
                return this.lastName + this.firstName;
            }
        };
        JSON.stringify(user) // "{"firstName":"三","lastName":"张","fullName":"张三"}
        // 对象有自定义的toJSON方法，那么JSON.stringify会使用这个方法的返回值作为参数，而忽略原对象的其他属性
        var user = {
            firstName: '三',
            lastName: '张',
            get fullName() {
                return this.lastName + this.firstName;
            },
            toJSON: function () {
                var data = {
                    firstName: this.firstName,
                    lastName: this.lastName
                };
                return data;
            }
        };
        JSON.stringify(user) // "{"firstName":"三","lastName":"张"}"

        // 把一个对象传入JSON.stringify(),序列化对象的顺序
        // 1.如果存在toJSON()方法而且能够通过它取得有效的值，则调用该方法。否则，返回对象本身
        // 2.如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第1步返回的值
        // 3.对第2步返回的每个值进行相应的序列化
        // 4.如果提供了第三个参数，执行相应的格式化

        // JSON.parse()将文本反序列化转化为对象
        // parse()如stringify()一样可以接受一个函数，函数的两个参数一个键一个值，而且都需要返回一个值，函数称作还原函数。
        // 如果还原函数返回undefined，则表示要从结果中删除对应的键，如果返回其他值，则将该值插入到结果中

        // JSON 安全问题：跨站请求伪造和跨站脚本攻击

        // 跨站请求伪造，利用站点对用户浏览器信任而发起攻击的方式。顶层JSON数组，JSON的最外边没有被{}包围而是一个数组，这是
        // 合法的JSON结构，但也是一个可执行的JavaScript脚本，会被script标签加载返回数据。
        // 解决方法：将JSON数组作为值放到JSON对象中，就不再是合法的JavaScript脚本，就不能被script加载，二仅允许POST请求获取数据，
        // 这样无法使用script中的链接

        // 跨站脚本攻击，注入攻击的一种，使用JSON常见的漏洞通常发生在JavaScript才能够服务器获取一段JSON字符串并将其转化为
        // JavaScript对象时
        // 使用eval解析JSON会执行恶意注入JSON的代码，所以避免使用eval解析JSON，而使用安全的JSON.parse()方法


    </script>
</body>

</html>