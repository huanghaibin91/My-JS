<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>异步</title>
</head>

<body>
    <p>异步运行图</p>
    <img src="./image/asyn.jpg" alt="">
    <p>下图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在"任务队列"中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取"任务队列"，依次执行那些事件所对应的回调函数</p>
    <img src="./image/eventloop.png" alt="">
    <script type="text/javascript">
        // 任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。
        // 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；
        // 异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，
        // 某个异步任务可以执行了，该任务才会进入主线程执行

        // 异步执行的运行机制
        // 所有同步任务都在主线程上执行， 形成一个执行栈（ execution context stack）
        // 主线程之外， 还存在一个 "任务队列"（task queue）。 只要异步任务有了运行结果， 就在 "任务队列"之中放置一个事件。
        // 一旦 "执行栈"中的所有同步任务执行完毕， 系统就会读取 "任务队列"，看看里面有哪些事件。 那些对应的异步任务， 
        // 于是结束等待状态， 进入执行栈， 开始执行。
        // 主线程不断重复上面的第三步

        // "任务队列"是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在"任务队列"中添加一个事件，
        // 表示相关的异步任务可以进入"执行栈"了。主线程读取"任务队列"，就是读取里面有哪些事件。

        // "任务队列"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。
        // 只要指定过回调函数，这些事件发生时就会进入"任务队列"，等待主线程读取。

        // 所谓"回调函数"（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，
        // 就是执行对应的回调函数。

        // "任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，
        // 只要执行栈一清空，"任务队列"上第一位的事件就自动进入主线程。但是，由于存在后文提到的"定时器"功能，
        // 主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。

        // 除了放置异步任务的事件，"任务队列"还可以放置定时事件
        setTimeout(function(){console.log(1);}, 0);
        console.log(2); // 执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行"任务队列"中的回调函数
        // 需要注意的是，setTimeout()只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会
        // 去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()
        // 指定的时间执行


    </script>
</body>

</html>
