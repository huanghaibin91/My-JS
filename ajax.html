<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Ajax</title>
</head>

<body>
    <script type="text/javascript">
        // Ajax,异步的JavaScript和XML
        // 核心是XMLHttpRequest

        // 跨浏览器创建XHR
        function createXHR() {
            if (typeof XMLHttpRequest !== 'undefined') {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== 'undefined') {
                if (typeof arguments.callee.activeXString !== 'string') {
                    var versions = ['MSXML2.XMLHttp.6.0', 'MSXML2.XMLHttp.6.0', 'MSXML2.XMLHttp'];
                    for (var i = 0; i < versions.length; i++) {
                        try {
                            new ActiveXObject(versions[i]);
                            arguments.callee.activeXString = versions[i];
                            break;
                        } catch (ex) {
                            // 跳过
                        }
                    }
                }
                return new ActiveXObject(arguments.callee.activeXString);
            } else {
                throw new Error('浏览器不支持XHR');
            }
        }

        // XHR使用
        // 创建新的XMLHttpRequest实例
        var xhr = createXHR();
        // 监听请求的状态变化
        xhr.onreadystatechange = function() {  // 使用实际的xhr对象而不用this，防止出现作用域问题
            if (xhr.readyState == 4) {
                if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
                    console.log(xhr.responseText);
                } else {
                    console.log('请求不成功' + xhr.status);
                }
            }
        }
        // get请求
        // 使用XHR对象时，调用的第一个方法是open(),接收三个参数，要发起请求的类型（'get','post'），请求的URL和表示是否异步发送请求的布尔值，false表示同步

        // 同步请求
        xhr.open('get', 'example.php', false);
        // send()方法，接收一个参数，即要作为请求主体发送的数据，如果不需要通过请求主体发送数据，则必须传入null
        xhr.send(null);
        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
            console.log(xhr.responseText);
        } else {
            console.log('request was unsuccessful' + xhr.status);
        }

        // XHR对象的属性
        // responseText，作为相应主体返回的文本
        // responseXML，保存包含响应数据的XML DOM文档
        // status，响应的HTTP状态，200表示成功，304表示请求的资源并没有被修改，可以直接使用浏览器缓存的版本，
        // statusText，HTTP状态的说明

        // 异步请求
        xhr.open('get', 'example.php', true);
        xhr.send(null);
        // 异步有readyState属性，表示当前响应的活动阶段，4表示完成
        // readyState每次变化会触发，readyStateChange事件
        xhr.onreadyStateChange = function() {
            if (xhr.readyState == 4) {
                if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
                    console.log(xhr.responseText);
                } else {
                    console.log('request was unsuccessful' + xhr.status);
                }
            }
        }

        // get请求，常用于向服务器查询某些信息
        // 查询字符串中每个参数的名称和值都必须使用encodeURIComponent()进行编码
        // 向URL的末尾添加查询字符串参数
        function addURLParam (url, name, value) {
            url += (url.index('?') == -1 ? '?' : '&');
            url += encodeURIComponent(name) + '=' + encodeURIComponent(value);
            return url;
        }

        // post请求，通常用于向服务器发送应该被保存的数据，通常用于表单提交

        // setRequestHeader(),设置http请求头部信息，两个参数头部字段的名称和头部字段的值，必须在调用open()之后send()之前调用setRequestHeader()
        // getResponseHeader(),可以取得相应的相应头部信息
        // getAllResponseHeaders(),可以取得所有头部信息的长字符串

        // FormData对象，序列化表单，使用formdata不必明确设置头部，XHR对象能够数据类型是formdata的实例
        var data = new FormData();
        data.append(key, value); // 两个参数，键和值，向data中添加数据
        data.append(document.form[0]);

        // 超时设定
        xhr.open('get', 'example.php', true);
        xhr.timeout = 1000; // 表示请求响应多少秒之后就终止
        xhr.ontimeout = function () { // 如果时间到了没有响应，就触发timeout事件
            console.log('request was not return in a second');
        };
        xhr.send(null);

        // 进度事件
        // load事件，在接收完整的响应数据时触发
        xhr.onload = function () {
            if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
                console.log(xhr.responseText);
            } else {
                console.log('response is not success' + xhr.status);
            }
        }
        // progresss事件，在刘拉你接收数据周期性触发，可以用来创建进度指示器，会接收一个event对象，event.target指向XHR，包含三个属性：
        // lengthComputable，表示进度信息是否可用
        // position，已经接收的字节数
        // totalSize，根据Content-Length响应头确定的预期字节数

        // 跨域安全策略，XHR对象只能访问包含它页面位于同一个域中的资源

        // CORS定义了必须访问跨域资源时，浏览器与服务器应该如何沟通。就是使用自定义的HTTP头部让浏览器与服务器精细沟通，从而决定请求或响应是应该成功，还是应该失败
        // 除IE外，其它浏览器用XMLHttpRequest原生支持CORS

        // 图像Ping，网页可以从任何其它网页加载图像，不用担心跨域。图像Ping是与服务器进行简单、单向的跨域通信。通过图像Ping，浏览器得不到任何具体的数据，但通过侦听load和error事件，它能知道响应是什么时候接收到的
        var img = new Image();
        img.onload = img.onerror = function () {
            console.log('Done!');
        }
        img.src = 'http://example.com/test/?name=Jack';

        // Comet，一种服务器向页面推送数据的技术，实现Comet的方式长轮询（浏览器定时向服务器发送请求，看有没有更新的数据）和流
        // 轮询使用setTime和XHR就能实现
        // HTTP流 


    </script>
</body>

</html>
