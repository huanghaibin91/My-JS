<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>对象</title>
</head>

<body>
    <script type="text/javascript">
        // 对象的键名都是字符串，非字符串会转化为字符串

        // JavaScript规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号

        // 对象的属性和方法:
        // obj.constructor: 保存着用于创建当前对象的函数
        // obj.hasOwnProperty(propertyName): 用于检验属性是否在实例中
        // obj.isPrototypeOf(object): 用于检查传入的对象是否是当前对象的原型
        // obj.propertyIsEnumerable(): 检查属性是否能用for-in枚举
        // obj.toLocalString():
        // obj.toString():
        // obj.valueOf():
        // delete，删除对象属性，只能删除自身的属性，不能删除继承的属性

        // Object.keys方法和Object.getOwnPropertyNames方法很相似，一般用来遍历对象的属性。
        // 它们的参数都是一个对象，都返回一个数组，该数组的成员都是对象自身的（而不是继承的）所有属性名。
        // 它们的区别在于，Object.keys方法只返回可枚举的属性（关于可枚举性的详细解释见后文），
        // Object.getOwnPropertyNames方法还返回不可枚举的属性名，不返回原型属性
        var o = {
            p1: 123,
            p2: 456
        };
        Object.keys(o) // ["p1", "p2"]
        Object.getOwnPropertyNames(o) // ["p1", "p2"]

        // 对象属性模型的相关方法
        // Object.getOwnPropertyDescriptor()：获取某个属性的attributes对象。
        // Object.defineProperty()：通过attributes对象，定义某个属性。
        // Object.defineProperties()：通过attributes对象，定义多个属性。
        // Object.getOwnPropertyNames()：返回直接定义在某个对象上面的全部属性的名称，不包含继承的属性键名

        // 控制对象状态的方法  
        // Object.preventExtensions()：防止对象扩展。
        // Object.isExtensible()：判断对象是否可扩展。
        // Object.seal()：禁止对象配置。
        // Object.isSealed()：判断一个对象是否可配置。
        // Object.freeze()：冻结一个对象。
        // Object.isFrozen()：判断一个对象是否被冻结。

        // 原型链相关方法
        // Object.create()：该方法可以指定原型对象和属性，返回一个新的对象。
        // Object.getPrototypeOf()：获取对象的Prototype对象

        // 对象可以通过两种形式定义： 声明（ 文字） 形式和构造形式。
        var myObj = { // 声明对象，常用
            key: 'hello',
            // ...
        };

        var myObj2 = new Object(); // 构造函数
        myObj2.key = 'hello';
        // 如果想访问key， 使用. 操作符或者 [] 操作符。 .a 语法通常被称为“ 属性访问”， ["a"] 语法通常被称为“ 键访问”。
        // . 操作符要求属性名满足标识符的命名规范， 而 [".."] 语法可以接受任意 UTF-8/Unicode 字符串作为属性名。
        // . 操作符要求属性名满足标识符的命名规范， 而 [".."] 语法可以接受任意 UTF-8/Unicode 字符串作为属性名。

        // 简单基本类型（ string、 boolean、 number、 null 和 undefined） 本身并不是对象。

        // 复制对象
        // 浅复制，浅拷贝来说， 复制出的新对象中的值会复制旧对象中的值， 但是新对象中 属性其实只是三个引用， 
        // 它们和旧对象中引用的对象是一样的，所以改变新对象的值，同样的旧对象的值也会改变。
        var arr1 = ["One", "Two", "Three"];
        var arr2 = arr1;
        arr2[1] = "test";
        console.log(arr1); // ['one', 'test', 'three']
        console.log(arr2); // ['one', 'test', 'three']

        // 深复制，两者不互相干扰
        var arr3 = ["One", "Two", "Three"];
        var arr4 = arr3.slice(0); // slice方法会返回一个新数组
        arr4[1] = 'test';
        console.log(arr3); // ['one', 'two', 'three']
        console.log(arr4); // ['one', 'test', 'three']

        // 属性描述符
        var myObject = {
            a: 2
        };
        Object.getOwnPropertyDescriptor(myObject, "a");
        console.log(Object.getOwnPropertyDescriptor(myObject, "a"));
        // 数据属性，属性描述对象
        // {
        // value: 2，默认undefined
        // writable: true,可写，决定可以修改属性的值，writable只有在从false改为true会报错，从true改为false则是允许的
        // enumerable: true,可枚举，，属性是否会出现在对象的属性枚举中，会被for...in循环遍历
        // 一个属性的enumerable为false，for..in循环，Object.keys方法，JSON.stringify方法不可取得属性
        // configurable: true,可配置，只要属性是可配置的， 就可以使用defineProperty(..) 方法来修改属性描述符，
        // 不可配置的属性也不可以删除
        // get: undefined, get存放一个函数，表示该属性的取值函数（getter），默认为undefined
        // set: undefined set存放一个函数，表示该属性的存值函数（setter），默认为undefined
        // }

        // 不变性，属性或者对象是不可改变，所有的方法创建的都是浅不变性， 也就是说， 它们只会影响目标对象和它的直接属性。
        //  如果目标对象引用了其他对象（ 数组、 对象、 函数， 等）， 其他对象的内容不受影响， 仍然是可变的

        // Object.defineProperty(),修改对象特性，接收三个参数：属性所在的对象，属性的名字和一个描述符对象，
        // 在调用Object.getOwnPropertyDescriptor()方法时，如果不指定writable,enumerable,configurable属性则默认值为false，IE支持版本IE8以上

        // 1. 对象常量，结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性（ 不可修改、重定义或者删除
        var myObject1 = {};
        Object.defineProperty(myObject1, "FAVORITE_NUMBER", {
            value: 42,
            writable: false,
            configurable: false
        });
        console.log(myObject1.FAVORITE_NUMBER); // 42
        //2. 禁止一个对象添加新属性并且保留已有属性，可以使用Object.preventExtensions(..)
        // Object.isExtensible()，方法用于检查一个对象是否使用了Object.preventExtensions方法
        var myObject2 = {
            a: 2
        };
        Object.preventExtensions(myObject2);
        myObject2.b = 3;
        myObject2.b; // undefined
        // 3.对象密封，Object.seal(..) 会创建一个“ 密封” 的对象， 这个方法实际上会在一个现有对象上调用
        // Object.preventExtensions(..) 并把所有现有属性标为configurable:false;密封之后不仅不能添加新属性， 
        // 也不能重新配置或者删除任何现有属性（ 虽然可以修改属性的值）。
        // Object.isSealed方法用于检查一个对象是否使用了Object.seal方法
        // 4.对象冻结，Object.freeze(..) 会创建一个冻结对象， 这个方法实际上会在一个现有对象上调用Object.seal(..) 
        // 并把所有“ 数据访问” 属性标记为 writable:false， 这样就无法修改它们的值。
        // Object.isFrozen方法用于检查一个对象是否使用了Object.freeze()方法

        // 判断对象中是否存在这个属性
        var myObject3 = {
            a: 2
        };
        ("a" in myObject3); // true，in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中
        ("b" in myObject3); // false
        myObject3.hasOwnProperty("a"); // true，hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链
        myObject3.hasOwnProperty("b"); // false

        // 读取访问器属性时，会调用getter函数，负责返回有效的值在；写入访问器函数时，会调用setter函数并传入新值，
        // 这个函数负责如何处理函数
        var book = {
            _year: 2017, // _year前面的下划线表示只能通过对象方法访问的属性,私有属性
            edition: 1,
        };

        // 访问器属性有四个configurable,enumerable,getter,setter,访问器属性只能使用Object.defineProperty()方法定义
        // 只指定getter意味着属性不能写，只指定setter意味属性不能读
        Object.defineProperty(book, 'year', {
            get: function () {
                return this._year;
            },
            set: function (newValue) {
                if (newValue > 2017) {
                    this._year = newValue;
                    this.edition += newValue - 2017;
                }
            }
        });
        book.year = 2018;
        console.log(book.edition); // 2018 - 2017 + 1 = 2
        // 存取器也可以使用Object.create方法定义，使用这种写法，属性foo必须定义一个属性描述对象。该对象的get和set属性，
        // 分别是foo的取值函数和存值函数
        var o = Object.create(Object.prototype, {
            foo: {
                get: function () {
                    return 'getter';
                },
                set: function (value) {
                    console.log('setter: ' + value);
                }
            }
        });
        // 利用存取器，可以实现数据对象与DOM对象的双向绑定
        Object.defineProperty(user, 'name', {
            get: function () {
                return document.getElementById('foo').value;
            },
            set: function (newValue) {
                document.getElementById('foo').value = newValue;
            },
            configurable: true
        });
        // Object.defineProperty方法来拷贝属性
        var extend = function (to, from) {
            for (var property in from) {
                var descriptor = Object.getOwnPropertyDescriptor(from, property);
                if (descriptor && (!descriptor.writable || !descriptor.configurable || !descriptor.enumerable ||
                        descriptor.get || descriptor.set)) {
                    Object.defineProperty(to, property, descriptor);
                } else {
                    to[property] = from[property];
                }
            }
        }

        // 同时可以操作多个对象属性的Object.defineProperties()方法
        Object.defineProperties(book, {
            _year: {
                writable: true,
                value: 2017
            },
            edition: {
                writable: true,
                value: 3
            }
        });
        console.log(book._year);
        console.log(book.edition);

        // 读取属性的特性，Object,getOwnPropertyDescriptor(),属性所在的对象和要读取其描述符的属性名称
        console.log(Object.getOwnPropertyDescriptor(book, '_year'));

        // 创建对象
        // 工厂模式
        function createPeerson(name, age) {
            var o = new Object();
            o.name = name;
            o.age = age;
            o.sayName = function () {
                console.log(this.name);
            }
            return o;
        }
        console.log(createPeerson('tom', 21));
        // 构造函数模式,构造函数跟普通函数一样，只是是用来创建对象的函数而已，作为普通函数调用，作用域会绑定到window，
        // this此时是默认绑定，函数此时会为window添加新属性和方法
        // 特点：没有显式的创建对象，直接将属性和方法赋值给this对象，没有return语句
        function Person(name, age) {
            this.name = name;
            this.age = age;
            this.sayName = function () {
                console.log(this.name);
            }
        }
        // 要创建构造函数新实例，必须使用new操作符：
        // 1.创建一个新对象
        // 2.将构造函数的作用域赋值给新对象
        // 3.执行构造函数中的代码
        // 4.返回新对象
        // 新对象会有一个constructor（构造函数）属性，指向prototype属性所在函数的指针
        console.log(new Person('Jack', 23)); // constructor属性指向Person，因为通过Person创建的对象的原型都是
        // Person构造函数的原型

        // 避免不使用new就调用构造函数
        function Fubar(foo, bar) {
            'use strict'; // 使用严格模式，普通调用会报错
            this._foo = foo;
            this._bar = bar;
        }
        Fubar() // 报错，不是以new模式调用
        // 构造函数内部判断是否使用new命令，如果发现没有使用，则直接返回一个实例对象
        function Fubar(foo, bar) {
            if (!(this instanceof Fubar)) {
                return new Fubar(foo, bar);
            }
            this._foo = foo;
            this._bar = bar;
        }
        Fubar(1, 2)._foo // 1 普通调用，通过判断返回一个新的new对象
        (new Fubar(1, 2))._foo // 1
        // 函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined
        function f() {
            if (!new.target) {
                throw new Error('请使用 new 命令调用！');
            }
            // ... 
        }
        f() // Uncaught Error: 请使用 new 命令调用！

        // 使用构造函数与原型模式组合来创建对象，实例方法与属性放在构造函数中，共享的属性和方法放在原型中
        function Person2(name, age) {
            this.name = name;
            this.age = age;
        }
        Person2.prototype = {
            constructor: Person2,
            sayName: function () {
                console.log(this.name);
            }
        }
    </script>
</body>

</html>