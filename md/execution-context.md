# 执行上下文 #


----------

当一个函数被调用时， 会创建一个活动记录（ 有时候也称为执行上下文）。 这个记录会包
含函数在哪里被调用（ 调用栈）、 函数的调用方法、 传入的参数等信息。 this 就是记录的
其中一个属性， 会在函数执行的过程中用到。

执行上下文，就是Js执行的时候的一个运行环境/作用域（scope）。执行上下文决定了Js执行过程中可以获取哪些变量、函数、数据，一段程序可能被分割成许多不同的上下文，每一个上下文都会绑定一个变量对象（variable object），它就像一个容器，用来存储当前上下文中所有已定义或可获取的变量、函数等。

**可执行代码**

既然执行上下文是在JS执行的时候创建的，那么JS中可执行代码的类型有：

- 全局代码，这个是默认的代码运行环境，一旦代码被载入，引擎最先进入的就是这个环境；
- 函数级别的代码，当执行一个函数时，运行函数体中的代码；
- Eval的代码，在Eval函数内运行的代码；

**执行上下文特点**

执行上下文有以下特点：

- 单线程；
- 同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待；
- 唯一的一个全局上下文，它在浏览器关闭时出栈；
- 函数的执行上下文的个数没有限制；
- 每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此；

**执行上下文的创建和执行**

- 上下文的创建阶段：函数被调用，但尚未开始执行（代码分析预处理阶段），此时会为执行上下文创建作用域链，创建变量、函数和参数以及求this的值。也就是发生声明提升的阶段；
- 执行阶段：指派变量的值和函数的引用并解释执行代码，在执行阶段，JS引擎会创建执行上下文栈来管理执行上下文；   

		var a = 1;
		function f() {
			var a = 2;
			function sayA() {
				console.log(a);
			}
			sayA();
		}
		f();
	
		// 我们用执行上下文解析上面代码
		// 代码执行之前，首先创建全局执行上下文，全局执行上下文入栈
		function f() {} // 函数声明先提升
		var a;
		a = 1;
		// 执行函数f之前，创建函数执行上下文，在函数中声明提升
		function f() {
			function sayA() {
				console.log(a);
			};
			var a;
			a = 2;
		}
		// 执行sayA，sayA函数入栈，弹出结果2，sayA函数出栈
		// f函数出栈
		// 如果是浏览器环境，关闭浏览器，全局执行上下文出栈
		
	
	



