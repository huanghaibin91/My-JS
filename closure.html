<!DOCTYPE html>
<html lang="en">

<head>
    <title>闭包</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="css/style.css" rel="stylesheet">
</head>

<body>
    <button id="myBtn">button</button>

    <script>
        // 产生闭包的三个条件是：
        // 1.调用的函数是父级作用域内部声明的
        // 2.调用的函数是在父级作用域之外进行调用
        // 3.调用的函数内部使用了父级作用域的内部变量

        // 当函数可以记住并访问所在的词法作用域， 即使函数是在当前词法作用域之外执行， 这时就产生了闭包。

        // 高程定义闭包：闭包是指有权访问另一个函数作用域中的变量的函数

        function foo() {
            var a = 2; // 3.调用的函数内部使用了父级作用域的内部变量

            function bar() { // 1.调用的函数是父级作用域内部声明的
                console.log(a);
            }
            return bar;
        }
        var baz = foo(); // 2.调用的函数是在父级作用域之外进行调用，foo()执行后将bar 函数本身当作一个值类型进行传递给baz。
        baz(); // 这就是闭包的效果。执行之后，输出foo中的a

        // 无论使用何种方式对函数类型的值进行传递， 当函数在别处被调用时都可以观察到闭包。
        function foo2() {
            var a = 2;

            function baz2() {
                console.log(a); // 2
            }
            bar2(baz2); // baz2被作为参数传递到外部函数bar2中
        }

        function bar2(fn) {
            fn(); // 这就是闭包！
        }

        // 无论通过何种手段将内部函数传递到所在的词法作用域以外， 它都会持有对原始定义作用域的引用， 无论在何处执行这个函数都会使用闭包。
        var fn3;

        function foo3() {
            var a = 2;

            function baz3() {
                console.log(a);
            }
            fn3 = baz3; // 将 baz3 分配给全局变量，也相当于传递到外部
        }

        function bar3() {
            fn3(); // 这就是闭包！
        }
        foo3();
        bar3(); // 2

        // 主要看看是否是外部调用。是的。因为用户点击时触发事件，不是在fun2中内部调用的。
        var fun2 = function() {
            var btn = document.querySelector("#myBtn");
            var x = 2;
            btn.onclick = function() {
                alert(x);
            }
        }
        fun2();

        // 将一个内部函数（ 名为 timer） 传递给 setTimeout(..)。 timer 具有涵盖 wait(..) 作用域的闭包， 因此还保有对变量 message 的引用。wait(..) 执行 1000 毫秒后， 它的内部作用域并不会消失， timer 函数依然保有 wait(..)作用域的闭包。
        function wait(message) {
            setTimeout(function timer() { // setTimeout.setInterval是window对象，算是外部函数,是在全局调用的
                console.log(message);
            }, 1000);
        }
        wait("Hello, closure!");

        // 首先解释 6 是从哪里来的。 这个循环的终止条件是 i 不再 <=5。 条件首次成立时 i 的值是6。 因此， 输出显示的是循环结束时 i 的最终值。延迟函数的回调会在循环结束时才执行。 事实上，当定时器运行时即使每个迭代中执行的是 setTimeout(.., 0)， 所有的回调函数依然是在循环结束后才会被执行， 因此会每次输出一个 6 出来。
        for (var i = 1; i <= 5; i++) { // 只有一个全局作用域
            setTimeout(function timer() {
                console.log(i); // 运行时会以每秒一次的频率输出五次 6
            }, i * 1000);
        }

        for (var i = 1; i <= 5; i++) {
            (function(j) { // 利用立即函数，每次循环创建单独的作用域并捕获每次循环的i作为参数传入
                setTimeout(function timer() {
                    console.log(j); // 能够正常输出1, 2, 3, 4, 5
                }, j * 1000);
            })(i);
        }

        for (let i = 1; i <= 5; i++) { // 使用let创建块级作用域
            setTimeout(function timer() {
                console.log(i); // 能够正常输出
            }, i * 1000);
        }

        // 模块有两个主要特征：（ 1） 为创建内部作用域而调用了一个包装函数；（ 2） 包装函数的返回值必须至少包括一个对内部函数的引用， 这样就会创建涵盖整个包装函数内部作用域的闭包。
        // 模块模式需要具备两个必要条件1. 必须有外部的封闭函数， 该函数必须至少被调用一次（ 每次调用都会创建一个新的模块实例）。2. 封闭函数必须返回至少一个内部函数， 这样内部函数才能在私有作用域中形成闭包， 并且可以访问或者修改私有的状态。
        var foo4 = (function CoolModule(id) {
            function change() {
                // 修改公共 API
                publicAPI.identify = identify2;
            }

            function identify1() {
                console.log(id);
            }

            function identify2() {
                console.log(id.toUpperCase());
            }
            var publicAPI = {
                change: change,
                identify: identify1
            };
            return publicAPI;
        })("foo module");
        foo4.identify(); // foo module
        foo4.change();
        foo4.identify(); // FOO MODULE


    </script>
</body>

</html>
