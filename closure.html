<!DOCTYPE html>
<html lang="en">

<head>
    <title>闭包</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
    <button id="myBtn">button</button>

    <script>
        // 产生闭包的三个条件是：
        // 1.调用的函数是父级作用域内部声明的
        // 2.调用的函数是在父级作用域之外进行调用
        // 3.调用的函数内部使用了父级作用域的内部变量

        // 当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行， 这时就产生了闭包。

        // 高程定义闭包：闭包是指有权访问另一个函数作用域中的变量的函数

        function foo() {
            var a = 2; // 3.调用的函数内部使用了父级作用域的内部变量
            function bar() { // 1.调用的函数是父级作用域内部声明的
                console.log(a);
            }
            return bar;
        }
        var baz = foo(); // 2.调用的函数是在父级作用域之外进行调用，foo()执行后将bar 函数本身当作一个值类型进行传递给baz。
        baz(); // 这就是闭包的效果。执行之后，输出foo中的a

        // 无论使用何种方式对函数类型的值进行传递， 当函数在别处被调用时都可以观察到闭包。
        function foo2() {
            var a = 2;
            function baz2() {
                console.log(a); // 2
            }
            bar2(baz2); // baz2被作为参数传递到外部函数bar2中
        }

        function bar2(fn) {
            fn(); // 这就是闭包！
        }
        foo2();

        // 无论通过何种手段将内部函数传递到所在的词法作用域以外， 它都会持有对原始定义作用域的引用， 无论在何处执行这个函数都会使用闭包。
        var fn3;

        function foo3() {
            var a = 2;
            function baz3() {
                console.log(a);
            }
            fn3 = baz3; // 将 baz3 分配给全局变量，也相当于传递到外部
        }

        function bar3() {
            fn3(); // 这就是闭包！
        }
        foo3();
        bar3(); // 2

        // 主要看看是否是外部调用。是的。因为用户点击时触发事件，不是在fun2中内部调用的。
        var fun2 = function () {
            var btn = document.querySelector("#myBtn");
            var x = 2;
            btn.onclick = function () {
                alert(x);
            }
        }
        fun2();

        // 将一个内部函数（ 名为 timer） 传递给 setTimeout(..)。 timer 具有涵盖 wait(..) 作用域的闭包， 
        // 因此还保有对变量 message 的引用。wait(..) 执行 1000 毫秒后， 它的内部作用域并不会消失， timer 函数
        // 依然保有 wait(..)作用域的闭包。
        function wait(message) {
            setTimeout(function timer() { // setTimeout.setInterval是window对象，算是外部函数,是在全局调用的
                console.log(message);
            }, 1000);
        }
        wait("Hello, closure!");

        // 首先解释 6 是从哪里来的。 这个循环的终止条件是 i 不再 <=5。 条件首次成立时 i 的值是6。 因此， 输出显示
        // 的是循环结束时 i 的最终值。延迟函数的回调会在循环结束时才执行。 事实上，当定时器运行时即使每个迭代中执行的是 
        // setTimeout(.., 0)， 所有的回调函数依然是在循环结束后才会被执行， 因此会每次输出一个 6 出来。
        for (var i = 1; i <= 5; i++) { // 只有一个全局作用域
            setTimeout(function timer() {
                console.log(i); // 运行时会以每秒一次的频率输出五次 6
            }, i * 1000);
        }

        for (var i = 1; i <= 5; i++) {
            (function (j) { // 利用立即函数，每次循环创建单独的作用域并捕获每次循环的i作为参数传入，立即函数是一个闭包，
            // 它会保留传入的参数i的值，当延迟函数在作用域之外调用时，仍能访问到i
                setTimeout(function timer() {
                    console.log(j); // 能够正常输出1, 2, 3, 4, 5
                }, j * 1000);
            })(i);
        }

        for (let i = 1; i <= 5; i++) { // 使用let创建块级作用域
            setTimeout(function timer() {
                console.log(i); // 能够正常输出
            }, i * 1000);
        }

        // 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，
        // 函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会
        // 被垃圾回收器释放。可是闭包的存在，会阻止这一过程
        // 虽然例子中的闭包被保存在了全局变量中，但是闭包的作用域链并不会发生任何改变。在闭包中，能访问到的变量，
        // 仍然是作用域链上能够查询到的变量
        // 即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果
        function createIncrementor(start) {
            return function () {
                return start++;
            };
        }
        var inc = createIncrementor(5);
        inc() // 5
        inc() // 6
        inc() // 7
        // 上面代码中，start是函数createIncrementor的内部变量。通过闭包，start的状态被保留了，
        // 每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数createIncrementor的内部环境，
        // 一直存在。所以，闭包可以看作是函数内部作用域的一个接口

        // 模块的一般形式是：一个定义了私有变量和函数的函数，利用闭包创建可以访问私有变量和函数的特权方法，
        // 最后返回这个特权函数，或者把它们保存到一个可访问到的地方
        // 模块有两个主要特征：（ 1） 为创建内部作用域而调用了一个包装函数；（ 2） 包装函数的返回值必须至少包括
        // 一个对内部函数的引用， 这样就会创建涵盖整个包装函数内部作用域的闭包。
        // 模块模式需要具备两个必要条件1. 必须有外部的封闭函数， 该函数必须至少被调用一次（ 每次调用都会创建一个新的模块实例）。2. 封闭函数必须返回至少一个内部函数， 这样内部函数才能在私有作用域中形成闭包， 并且可以访问或者修改私有的状态。
        var foo4 = (function CoolModule(id) {
            function change() {
                // 修改公共 API
                publicAPI.identify = identify2;
            }

            function identify1() {
                console.log(id);
            }

            function identify2() {
                console.log(id.toUpperCase());
            }
            var publicAPI = {
                change: change,
                identify: identify1
            };
            return publicAPI;
        })("foo module");
        foo4.identify(); // foo module
        foo4.change();
        foo4.identify(); // FOO MODULE
    </script>
</body>

</html>
