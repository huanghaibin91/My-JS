<!DOCTYPE html>
<html lang="en">

<head>
    <title></title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
    <!-- script -->
    <script>
        //  这种方法将私有变量封装在构造函数中，违反了构造函数与实例对象相分离的原则。并且，非常耗费内存
        function StringBuilder() {
            var buffer = [];
            this.add = function (str) {
                buffer.push(str);
            };
            this.toString = function () {
                return buffer.join('');
            };
        }

        // 这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全
        function StringBuilder() {
            this._buffer = [];
        }
        StringBuilder.prototype = {
            constructor: StringBuilder,
            add: function (str) {
                this._buffer.push(str);
            },
            toString: function () {
                return this._buffer.join('');
            }
        };
        
        // 使用立即执行函数加闭包生成模块
        // 使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，
        // 可以达到不暴露私有成员的目的
        var module1 = (function () {　
            var _count = 0;　
            var m1 = function () {　 //...
                　};　
            var m2 = function () {　　 //...
                　};　
            return {　　
                m1: m1,
                m2: m2　
            };
        })();

        // 如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）
        var module1 = (function (mod) { // 将module1作为参数传入　
            mod.m3 = function () {　　// 为module1添加新方法
                //...
            };　
            return mod; // 返回新的module1
        })(module1);

        // 在浏览器环境中，模块的各个部分通常都是从网上获取的，
        // 有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用"宽放大模式"
        var module1 = (function (mod) {　 
            //...
            return mod;
        })(window.module1 || {}); // 与"放大模式"相比，＂宽放大模式＂就是"立即执行函数"的参数可以是空对象

        // 通行的Javascript模块规范共有两种：CommonJS和AMD。我主要介绍AMD，但是要先从CommonJS讲起
        // node.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。
        // 属于同步加载，浏览器端的模块，不能采用"同步加载"（synchronous），只能采用"异步加载"（asynchronous）。
        // 这就是AMD规范诞生的背景

        // AMD是"Asynchronous Module Definition"的缩写，意思就是"异步模块定义"它采用异步方式加载模块，
        // 模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行
        // AMD更适合浏览器环境

        // require.js：（1）实现js文件的异步加载，避免网页失去响应；（2）管理模块之间的依赖性，便于代码的编写和维护。


    </script>
</body>

</html>