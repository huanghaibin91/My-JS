<!DOCTYPE html>
<html lang="en">

<head>
    <title>作用域</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
    <script>
        // 变量的赋值操作会执行两个动作， 首先编译器会在当前作用域中声明一个变量（ 如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量， 如果能够找到就会对它赋值。赋值操作符会导致 LHS 查询。 ＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。

        // 所以 var a = 2; 拆解=> var a; a = 2; 两步
        // 1. 首先， var a 在其作用域中声明新变量。 这会在最开始的阶段， 也就是代码执行前进行。
        // 2. 接下来， a = 2 会查询（ LHS 查询） 变量 a 并对其进行赋值。

        // RHS 查询与简单地查找某个变量的值别无二致，RHS 理解成 retrieve his source value（ 取到它的源值）， 这意味着“ 得到某某的值”。 而 LHS 查询则是试图找到变量的容器本身， 从而可以对其赋值。
        // 可以理解为LHS为找到变量，RHS为找到变量的值
        // 查找的目的是对变量进行赋值， 那么就会使用 LHS 查询； 如果目的是获取变量的值， 就会使用 RHS 查询。


        // 遍历嵌套作用域链的规则很简单： 引擎从当前的执行作用域开始查找变量， 如果找不到，就向上一级继续查找。 当抵达最外层的全局作用域时， 无论找到还是没找到， 查找过程都会停止。

        // 不成功的 RHS 引用会导致抛出 ReferenceError 异常。 不成功的 LHS 引用会导致自动隐式地创建一个全局变量（ 非严格模式下）， 该变量使用 LHS 引用的目标作为标识符， 或者抛出 ReferenceError 异常（ 严格模式下）。

        // 词法作用域就是定义在词法阶段的作用域。 换句话说， 词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的， 因此当词法分析器处理代码时会保持作用域不变（ 大部分情况下是这样的）。

        // 作用域查找会在找到第一个匹配的标识符时停止。 在多层的嵌套作用域中可以定义同名的标识符， 这叫作“ 遮蔽效应”（ 内部的标识符“ 遮蔽” 了外部的标识）。

        // 无论函数在哪里被调用， 也无论它如何被调用， 它的词法作用域都只由函数被声明时所处的位置决定。
        function foo() {
            console.log(a); // 2
        }
        bar(); // 输出undefined
        function bar() {
            var a = 3;
            foo(); // 输出2，因为foo定义时的作用域的a为全局的a = 2,说明函数不管在哪里调用都是基于它定义时的作用域
        }
        var a = 2;
        bar();

        // 欺骗词法作用域的两种方法，两个都不推荐使用
        // JavaScript 中的 eval(..) 函数可以接受一个字符串为参数， 并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。 换句话说， 可以在你写的代码中用程序生成代码并运行， 就好像代码是写在那个位置的一样。
        function foo1(str, a) {
            eval(str); // 欺骗！
            console.log(a, b);
        }
        var b = 2;
        foo1("var b = 3;", 1); // 1, 3, eval中的b遮蔽了全局中的b,让作用域弹出的b改变了
        // JavaScript 中另一个难以掌握（ 并且现在也不推荐使用） 的用来欺骗词法作用域的功能是with 关键字。
        // with 通常被当作重复引用同一个对象中的多个属性的快捷方式， 可以不需要重复引用对象本身。
        var obj = {
            a: 1,
            b: 2,
            c: 3
        };
        // 单调乏味的重复 "obj"
        obj.a = 2;
        obj.b = 3;
        obj.c = 4;
        // 简单的快捷方式
        with(obj) {
            a = 3;
            b = 4;
            c = 5;
        }
        // with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域， 因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。
        function foo2(obj) {
            with(obj) {
                a = 2;
            }
        }
        var o1 = {
            a: 3
        };
        var o2 = {
            b: 3
        };
        foo2(o1);
        console.log(o1.a); // 2，o1中有a属性，所以传入后将属性a修复赋值为2
        foo2(o2);
        console.log(o2.a); // undefined，o2中没有a属性，所以弹出undefined;
        console.log(a); // 2——不好， a 被泄漏到全局作用域上，因为o2中没有a，因此进行了正常的 LHS 标识符查找，最后没有找到a，如果在作用域中找到a，就会修改那个a为2，因此当 a＝2 执行时， 自动创建了一个全局变量（ 因为是非严格模式）。

        // 基于作用域的隐藏方法。 它们大都是从最小特权原则中引申出来的， 也叫最小授权或最小暴露原则。 这个原则是指在软件设计中， 应该最小限度地暴露必要内容， 而将其他内容都“ 隐藏” 起来， 比如某个模块或对象的 API 设计。

        // 区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位置（ 不仅仅是一行代码， 而是整个声明中的位置）。 如果 function 是声明中的第一个词， 那么就是一个函数声明， 否则就是一个函数表达式。
        // 函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。

        // 匿名函数表达式书写起来简单快捷，但有以下的缺点
        // 1. 匿名函数在栈追踪中不会显示出有意义的函数名， 使得调试很困难。
        // 2. 如果没有函数名， 当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如在递归中。 另一个函数需要引用自身的例子， 是在事件触发后事件监听器需要解绑自身。
        // 3. 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。 一个描述性的名称可以让代码不言自明。

        // 块级作用域
        //  with 关键字。是块作用域的一个例子（ 块作用域的一种形式）， 用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。
        // JavaScript 的 ES3 规范中规定 try/catch 的 catch 分句会创建一个块作用域， 其中声明的变量仅在 catch 内部有效。
        try {
            undefined(); // 执行一个非法操作来强制制造一个异常
        } catch (err) {
            console.log(err); // 能够正常执行！
        }
        console.log(err); // ReferenceError: err not found
        // let 关键字， 提供了除 var 以外的另一种变量声明方式。let 关键字可以将变量绑定到所在的任意作用域中（ 通常是 { .. } 内部）。 换句话说， let为其声明的变量隐式地了所在的块作用域。

        // 先有声明，再有赋值，变量提升
        b = 2;
        var b;
        console.log(b); // 2

        console.log(c); // undefined
        var c = 2;

        // 函数声明会被提升， 但是函数表达式却不会被提升
        // 函数声明和变量声明都会被提升。 但是一个值得注意的细节（ 这个细节可以出现在有多个“ 重复” 声明的代码中） 是函数会首先被提升， 然后才是变量。

        // 我们习惯将 var a = 2; 看作一个声明， 而实际上 JavaScript 引擎并不这么认为。 它将 var a和 a = 2 当作两个单独的声明， 第一个是编译阶段的任务， 而第二个则是执行阶段的任务。这意味着无论作用域中的声明出现在什么地方， 都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（ 变量和函数） 都会被“ 移动” 到各自作用域的最顶端， 这个过程被称为提升。

        
    </script>
</body>

</html>
