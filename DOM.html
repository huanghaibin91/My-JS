<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>文档对象模型</title>
</head>

<body>
    <img src="/image/size.png" alt=""><br>
    <img src="./image/size2.png" alt=""><br>
    <img src="./image/size3.png" alt=""><br>
    <img src="./image/size4.png" alt=""><br>
    <img src="./image/size5.png" alt=""><br>
    <ul class="ul">
        <li class="li1">1</li>
        <li class="li2">2</li>
        <li class="li3">3</li>
    </ul>
    <script type="text/javascript">
        window.onload = function () {
            document.querySelector('.ul').classList.add('active');
        }
        // Document：整个文档树的顶层节点
        // document节点有不同的办法可以获取：
        // 对于正常的网页，直接使用document或window.document。
        // 对于iframe载入的网页，使用iframe节点的contentDocument属性。
        // 对Ajax操作返回的文档，使用XMLHttpRequest对象的responseXML属性。
        // 对于包含某个节点的文档，使用该节点的ownerDocument属性
        // DocumentType：doctype标签（比如<!DOCTYPE html>），document.doctype
        // document.documentElement，返回HTML元素
        // document.defaultView属性，在浏览器中返回document对象所在的window对象，否则返回null
        // document.documentURI（所有文档），document.URL（HTML文档）表示当前文档的网址。document.domain返回当前文档的域名
        // document.location，属性返回location对象，提供了当前文档的URL信息

        // Element元素节点
        // Element.id，Element.tagName，Element.className
        // classList类名集合,以下是它的方法
        // add()，添加类名
        // contains()，是否有类名
        // remove()，移除类名
        // toggle()，检查是否有类名，有就删除，没有就添加
        // innerHTML，读模式属性返回与调用元素的所有子节点对应的HTML标记，写模式会被解析为DOM子树，替换调用元素所有的子节点，但是通过innerHTML插入script无效
        // outerHTML，读模式属性返回与调用元素及其所有子节点对应的HTML标记，写模式会被解析为DOM子树，替换调用元素及其所有的子节点
        // innerText,读模式可以操作元素中包含的所有文本，包括子文档树中的文本，写模式下会替换掉元素的所有子节点，使元素只有一个子文本节点，
        // outerText，读模式下与innerText一致，写模式下会用文本节点替换掉元素及其子节点
        // 元素尺寸,以下属性都是只读属性，不可赋值
        // offsetHeight，元素垂直空间高度，包括边框与滚动条
        // offsetWidth，元素水平空间高度，包括边框与滚动条
        // offsetTop，元素上外边框与与包含元素上内边框的距离
        // offsetLeft，元素左外边框与与包含元素左内边框的距离
        // 包含元素保存在offsetParent，不一定与parentNode相同，因为offsetParent是要能够设置大小的元素
        // clientHeight，元素内容及其内边距所占高度，不包含滚动条与边框
        // clientWidth，元素内容及其内边距所占宽度，不包含滚动条与边框
        // 滚动大小
        // scrollHeight，在没有滚动条的情况下，元素内容的总高度
        // scrollWidth，在没有滚动条的情况下，元素内容的总高度
        // scrollTop，内容区域上方滚动的像素，可以设置改变滚动位置
        // scrollLeft，内容区域左侧滚动的像素，可以设置改变滚动位置

        // ele.scrollIntoView()，参数默认true，页面（或容器）发生滚动，使element的顶部与视图（容器）顶部对齐；参数为false，
        // 使element的底部与视图（容器）底部对齐。应用场景，聊天新信息到了直接滚动到底部显示

        // 文本节点
        // createTextNode
        // remove()移出文本节点，splitText(target)从target位置分割文本节点，normalize()合并文本节点

        // appendData(str)把str放置在文本节点末尾，deleteData(target, length)，insertData(target, str)，
        // replaceData(target, length, str)，subStringData(target, length)文本节点操作方法
        // HTML代码为 
        // <p>Hello World</p> 
        // var pElementText = document.querySelector('p').firstChild; 
        // pElementText.appendData('!'); // 页面显示 Hello World! 
        // pElementText.deleteData(7,5); // 页面显示 Hello W 
        // pElementText.insertData(7,'Hello '); // 页面显示 Hello WHello 
        // pElementText.replaceData(7,5,'World'); // 页面显示 Hello WWorld 
        // pElementText.substringData(7,10); // 页面显示不变，返回"World "

        // Element：网页的各种HTML标签（比如<body>、<a>等）
        // Attribute：网页元素的属性（比如class="right"）
        // Text：标签之间或标签包含的文本
        // Comment：注释
        // DocumentFragment：文档的片段

        // 元素节点，属性节点，文本节点
        // nodeType, 元素节点1，属性节点2，文本节点3
        // nodeName,元素节点保存元素的标签名，tagName也可以
        // nodeValue，元素节点为null，文本节点为文本内容
        // textContent，回当前节点和它的所有后代节点的文本内容，会把其中的标签解释为文本

        // 节点树结构
        // parentNode,父节点，对于一个节点来说，它的父节点只可能是三种类型：element节点、document节点和documentFragment节点
        // childNodes,所有子节点,基于DOM结构动态查询的结果，因此DOM结构的变化能够自动反映在Nodelist对象中
        // children，所有子元素节点
        // firstChild,第一个子节点，firstElementChild第一个元素子节点,如果当前节点没有子节点，则返回null
        // lastChild，最后一个子节点, lastElementChild最后一个元素子节点
        // nextSibling，下一个兄弟节点,nextElementSibling下一个元素兄弟节点
        // previousSibing，上一个兄弟节点,previousElementSibing上一个元素兄弟节点

        // hasChildNodes()，方法检测 元素是否有子节点
        // childElementCount，返回子元素的个数
        // parentNode.appendChild(newNode),在父节点末尾添加一个节点，如果目标节点已经是文档的一部分了，
        // 那结果就是将该节点从原来的的位置移动到新位置
        // parentNode.insertBefore(newNode,targetNode)，在父节点的某个子节点之前添加一个节点，目标位置参数
        // null则跟appendChild()一样,
        // 如果所要插入的节点是当前DOM现有的节点，则该节点将从原有的位置移除，插入新的位置
        // parentNode.replaceChild(newNode, oldNode)，替换一个子节点
        // parentNode.removeChild(node)，移出一个子节点
        // cloneNode(),复制节点，接收一个参数，表示是否执行深复制，深复制会复制其整个子节点树。这个方法不会
        // 复制添加到DOM节点中的JavaScript属性，例如事件处理等

        // Node.contains(), 接受一个节点作为参数，返回一个布尔值，表示参数节点是否为当前节点的后代节点
        // Node.isEqualNode(), 返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、
        // 属性相同、子节点相同
        // Node.normalize(), normailize方法用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本
        // 节点合并成一个

        // document.documentElement取得html,document.body取得body

        // HTMLCollection实例对象与NodeList实例对象类似，也是节点的集合，返回一个类似数组的对象。
        // document.links、docuement.forms、document.images等属性，返回的都是HTMLCollection实例对象，
        // HTMLCollection只能是元素集合
        // docuemnt.title取得文档标题
        // document.forms取得所有表单元素
        // document.images取得所有图像元素
        // document.links取得所有带href特性的a元素
        // document.embeds属性返回网页中所有嵌入对象，即embed标签
        // document.getElementsByName()，返回有指定name的元素，常用情况是取得单选按钮，name相同的单选按钮只有选中
        // 那个会被获取

        // 属性节点
        // nodeName特性的名称，nodeValue特性的值，parentNode值为null
        // getAttribute()
        // setAttribute()
        // hasAttribute()
        // removeAttribute()
        // element.attributes，返回一个类似数组的动态对象，成员是该元素标签的所有属性节点对象，性节点对象有name和value属性

        // document.createElement()
        // document.createTextNode()

        // normalize()合并元素的文本节点，将元素下多个文本节点合并为一个
        // splitText()将一个文本节点分成两个，参数是文本位置

        // DocumentFragment，没有对应的标记，可以作为‘仓库’使用
        // var fragment = document.creatDocumentFragment();
        // var ul = document.getElementsByTagName('ul');
        // for (var i = 0; i < 3; i++) {
        //     var  li = document.createElement('li');
        //     fragment.appendChild(li); // 利用DocumentFragment作为仓库先储存元素，最后再一起插入目标元素，避免浏览器多次渲染
        // }
        // ul.appendChild(fragment);

        // querySelector()、querySelectorAll()，接收以个CSS选择符，并获取匹配元素,返回的是一个静态集合。
        // DOM内部的变化，并不会实时反映在该方法的返回结果之中

        // document.activeElement(),DOM中当前获得焦点的元素
        // document.hasFocus(),确定文档是否获取了焦点

        // document.readyState，有两个值loading和complete，用来实现一个指示文档已经加载完成的指示器
        // 浏览器开始解析HTML文档，document.readyState属性等于loading。
        // 浏览器遇到HTML文档中的<script>元素，并且没有async或defer属性，就暂停解析，开始执行脚本，这时
        // document.readyState属性还是等于loading。
        // HTML文档解析完成，document.readyState属性变成interactive。
        // 浏览器等待图片、样式表、字体文件等外部资源加载完成，一旦全部加载完成，document. readyState属性变成complete。

        // style特性，包含元素HTML标签中的style样式，不包含外部链接样式，所以通过style设置样式，设置的是内联样式。
        // 设置外部样式可以通过设置类名或id连接外部样式表
        // Style对象的以下三个方法，用来读写行内CSS规则：setProperty()，getPropertyValue()，removeProperty()
        // 三个方法的第一个参数，都是CSS属性名，且不用改写连词线
        // CSSText可以方便设置style特性中的CSS代码
        // 前浏览器是否支持某个模块，叫做“CSS模块的侦测”，利用typeof不支持会返回undefined
        typeof element.style.animationName === 'string';
        // 检测浏览器是否支持CSS属性的函数
        function isPropertySupported(property) {
            if (property in document.body.style) return true;
            var prefixes = ['Moz', 'Webkit', 'O', 'ms', 'Khtml'];
            var prefProperty = property.charAt(0).toUpperCase() + property.substr(1);
            for (var i = 0; i < prefixes.length; i++) {
                if ((prefixes[i] + prefProperty) in document.body.style) return true;
            }
            return false;
        }
        // 计算样式，元素所有样式，getComputedStyle,currentStyle(IE中)，计算样式都是只读的
        // 返回的CSS值都是绝对单位，比如，长度都是像素单位（返回值包括px后缀），颜色是rgb(#, #, #)或rgba(#, #, #, #)格式。
        // CSS规则的简写形式无效，比如，想读取margin属性的值，不能直接读，只能读marginLeft、marginTop等属性。
        // 如果一个元素不是绝对定位，top和left属性总是返回auto。
        // 该方法返回的样式对象的cssText属性无效，返回undefined。
        // 该方法返回的样式对象是只读的，如果想设置样式，应该使用元素节点的style属性
        // var computedStyle = document.defaultView.getComputedStyle(node, null); 两个参数是计算样式的元素和一个伪元素字符串，
        // 如":after"，不需要伪元素则写null，会返回一个包含所有计算属性的对象
        // var computedStyle = node.currentStyle;
        // 有可能不会显示综合属性，就是几个CSS属性简写在一起的，所以查询的时候写详细的属性

        // Mutation Observer API 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知
        // 它等待所有脚本任务完成后，才会运行，即采用异步方式。
        // 它把 DOM 变动记录封装成一个数组进行处理，而不是一条条地个别处理 DOM 变动。
        // 它既可以观察发生在 DOM 的所有类型变动，也可以观察某一类变动
        var observer = new MutationObserver(callback); // 回调函数接受两个参数，第一个是变动数组，第二个是观察器实例
        var observer = new MutationObserver(function (mutations, observer) {
            mutations.forEach(function (mutation) {
                console.log(mutation);
            });
        });
        // observe方法用来开始监听，它接受两个参数第一个参数是所要观察的 DOM 节点第二个参数是一个配置对象，用来指定所要观察的特定变动
        var article = document.querySelector('article');
        var options = {
            'childList': true,
            'attributes': true
        };
        observer.observe(article, options);
        // 察器所能观察的 DOM 变动类型（即上面代码的options对象），有以下几种
        // childList：子节点的变动
        // attributes：属性的变动
        // characterData：节点内容或节点文本的变动
        // subtree：所有后代节点的变动如果，设置观察subtree的变动，必须同时指定childList、attributes和characterData中的一种或多种
        // attributeOldValue：类型为布尔值，表示观察attributes变动时，是否需要记录变动前的属性值
        // characterDataOldValue：类型为布尔值，表示观察characterData变动时，是否需要记录变动前的值
        // attributeFilter：类型为数组，表示需要观察的特定属性（比如['class','src']）
        // observer.disconnect();用来停止观察。调用该方法后，DOM 再发生变动，也不会触发观察器
        // observer.takeRecords();用来清除变动记录，即不再处理未处理的变动。该方法返回变动记录的数组
        // MutationRecord 对象，DOM 每次发生变化，就会生成一条变动记录。这个变动记录对应一个MutationRecord对象
        // MutationRecord对象包含了DOM的相关信息，有如下属性：
        // type：观察的变动类型（attribute、characterData或者childList）。
        // target：发生变动的DOM节点。
        // addedNodes：新增的DOM节点。
        // removedNodes：删除的DOM节点。
        // previousSibling：前一个同级节点，如果没有则返回null。
        // nextSibling：下一个同级节点，如果没有则返回null。
        // attributeName：发生变动的属性。如果设置了attributeFilter，则只返回预先指定的属性。
        // oldValue：变动前的值。这个属性只对attribute和characterData变动有效，如果发生childList变动，则返回null。
        

        // 浏览器窗口大小
        function getViewport() {
            if (document.compatMode == 'BackCompat') {
                return {
                    width: document.body.clientWidth,
                    height: document.bode.clientHeight
                }
            } else {
                return {
                    width: document.documentElement.clientWidth,
                    height: document.documentElement.clientHeight
                }
            }
        }

        //解决获取类名
        //第一个参数node表示DOM树中的搜索起点
        //第二个参数classname就是要搜索的类名
        function getElementsByClassName(node, classname) {
            if (node.getElementsByClassName) {
                //支持直接取得类名，直接使用现有方法
                return node.getElementsByClassName(classname);
            } else {
                var results = new Array();
                var elems = node.getElementsByTagName("*");
                for (var i = 0; i < elems.length; i++) {
                    if (elems[i].className.indexOf(classname) != -1) {
                        results[results.length] = elems[i];
                    }
                }
                return results;
            }
        }

        //取得ID名下的类
        function getClassName(className, idName) {
            var node = null;
            if (arguments.length == 2) {
                node = document.getElementById(idName);
            } else {
                node = document;
            }
            var all = node.getElementsByTagName('*');
            for (var i = 0; i < all.length; i++) {
                if (all[i].className == className) {
                    this.elements.push(all[i]);
                }
            }
            return this;
        }
    </script>
</body>

</html>