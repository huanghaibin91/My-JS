<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>文档对象模型</title>
</head>

<body>
    <img src="./image/size2.png" alt=""><br>
    <img src="./image/size3.png" alt=""><br>
    <img src="./image/size4.png" alt=""><br>

    <script type="text/javascript">
        // 元素节点，属性节点，文本节点
        // nodeType, 元素节点1，属性节点2，文本节点3
        // nodeName,元素节点保存元素的标签名，tagName也可以
        // nodeValue，元素节点为null，文本节点为文本内容

        // parentNode,父节点
        // childNodes,所有子节点,基于DOM结构动态查询的结果，因此DOM结构的变化能够自动反映在Nodelist对象中
        // hasChildNodes()，方法检测 元素是否有子节点
        // children，所有子元素节点
        // firstChild,第一个子节点，firstElementChild第一个元素子节点
        // lastChild，最后一个子节点, lastElementChild最后一个元素子节点
        // nextSibling，下一个兄弟节点,nextElementSibling下一个元素兄弟节点
        // previousSibing，上一个兄弟节点,previousElementSibing上一个元素兄弟节点

        // parentNode.appendChild(newNode),在父节点末尾添加一个节点，如果目标节点已经是文档的一部分了，那结果就是将该节点从原来的的位置移动到新位置
        // parentNode.insertBefore(newNode,targetNode)，在父节点的某个子节点之前添加一个节点，目标位置参数null则跟appendChild()一样
        // parentNode.replaceChild(newNode, oldNode)，替换一个子节点
        // parentNode.removeChild(node )，移出一个子节点

        // cloneNode(),复制节点，接收一个参数，表示是否执行深复制，深复制会复制其整个子节点树。这个方法不会复制添加到DOM节点中的JavaScript属性，例如事件处理等

        // document.documentElement取得html,document.body取得body
        // docuemnt.title取得文档标题
        // document.forms取得所有表单元素
        // document.images取得所有图像元素
        // document.links取得所有带href特性的a元素
        // document.getElementsByName()，返回有指定name的元素，常用情况是取得单选按钮，name相同的单选按钮只有选中那个会被获取

        // getAttribute()
        // setAttribute()
        // removeAttribute()

        // document.createElement()
        // document.createTextNode()

        // normalize()合并元素的文本节点，将元素下多个文本节点合并为一个
        // splitText()将一个文本节点分成两个，参数是文本位置

        // DocumentFragment，没有对应的标记，可以作为‘仓库’使用
        // var fragment = document.creatDocumentFragment();
        // var ul = document.getElementsByTagName('ul');
        // for (var i = 0; i < 3; i++) {
        //     var  li = document.createElement('li');
        //     fragment.appendChild(li); // 利用DocumentFragment作为仓库先储存元素，最后再一起插入目标元素，避免浏览器多次渲染
        // }
        // ul.appendChild(fragment);

        // querySelector()、querySelectorAll()，接收以个CSS选择符，并获取匹配元素

        // childElementCount，返回子元素的个数

        // classList类名集合,以下是它的方法
        // add()，添加类名
        // contains()，是否有类名
        // remove()，移除类名
        // toggle()，检查是否有类名，有就删除，没有就添加

        // document.activeElement(),DOM中当前获得焦点的元素
        // document.hasFocus(),确定文档是否获取了焦点

        // document.readyState，有两个值loading和complete，用来实现一个指示文档已经加载完成的指示器

        // innerHTML，读模式属性返回与调用元素的所有子节点对应的HTML标记，写模式会被解析为DOM子树，替换调用元素所有的子节点，但是通过innerHTML插入script无效
        // outerHTML，读模式属性返回与调用元素及其所有子节点对应的HTML标记，写模式会被解析为DOM子树，替换调用元素及其所有的子节点

        // innerText,读模式可以操作元素中包含的所有文本，包括子文档树中的文本，写模式下会替换掉元素的所有子节点，使元素只有一个子文本节点，
        // outerText，读模式下与innerText一致，写模式下会用文本节点替换掉元素及其子节点

        // style特性，包含元素HTML标签中的style样式，不包含外部链接样式，所以通过style设置样式，设置的是内联样式。设置外部样式可以通过设置类名或id连接外部样式表
        // CSSText可以方位设置style特性中的CSS代码
        // getPropertyValue，获取CSS属性值的字符串表示
        // removeProperty，移除一个CSS属性

        // 计算样式，元素所有样式，getComputedStyle,currentStyle(IE中)，计算样式都是只读的
        // var computedStyle = document.defaultView.getComputedStyle(node, null); 两个参数是计算样式的元素和一个伪元素字符串，如":after"，不需要伪元素则写null，会返回一个包含所有计算属性的对象
        // var computedStyle = node.currentStyle;
        // 有可能不会显示综合属性，就是几个CSS属性简写在一起的，所以查询的时候写详细的属性

        // 元素尺寸,以下属性都是只读属性，不可赋值
        // offsetHeight，元素垂直空间高度，包括边框与滚动条
        // offsetWidth，元素水平空间高度，包括边框与滚动条
        // offsetTop，元素上外边框与与包含元素上内边框的距离
        // offsetLeft，元素左外边框与与包含元素左内边框的距离
        // 包含元素保存在offsetParent，不一定与parentNode相同，因为offsetParent是要能够设置大小的元素
        // clientHeight，元素内容及其内边距所占高度，不包含滚动条与边框
        // clientWidth，元素内容及其内边距所占宽度，不包含滚动条与边框

        // 浏览器窗口大小
        function getViewport() {
            if (document.compatMode == 'BackCompat') {
                return {
                    width: document.body.clientWidth,
                    height: document.bode.clientHeight
                }
            } else {
                return {
                    width: document.documentElement.clientWidth,
                    height: document.documentElement.clientHeight
                }
            }
        }

        // 滚动大小
        // scrollHeight，在没有滚动条的情况下，元素内容的总高度
        // scrollWidth，在没有滚动条的情况下，元素内容的总高度
        // scrollTop，内容区域上方滚动的像素，可以设置改变滚动位置
        // scrollLeft，内容区域左侧滚动的像素，可以设置改变滚动位置

        //解决获取类名
        //第一个参数node表示DOM树中的搜索起点
        //第二个参数classname就是要搜索的类名
        function getElementsByClassName(node, classname) {
            if (node.getElementsByClassName) {
                //支持直接取得类名，直接使用现有方法
                return node.getElementsByClassName(classname);
            } else {
                var results = new Array();
                var elems = node.getElementsByTagName("*");
                for (var i = 0; i < elems.length; i++) {
                    if (elems[i].className.indexOf(classname) != -1) {
                        results[results.length] = elems[i];
                    }
                }
                return results;
            }
        }

        //取得ID名下的类
        function getClassName(className, idName) {
            var node = null;
            if (arguments.length == 2) {
                node = document.getElementById(idName);
            } else {
                node = document;
            }
            var all = node.getElementsByTagName('*');
            for (var i = 0; i < all.length; i++) {
                if (all[i].className == className) {
                    this.elements.push(all[i]);
                }
            }
            return this;
        }
    </script>
</body>

</html>
