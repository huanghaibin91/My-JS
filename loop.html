<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>循环</title>
</head>

<body>
    <img src="./image/loop1.jpg" alt="">
    <script type="text/javascript">
        // Javascript的事件分为同步任务和异步任务，遇到同步任务就放在执行栈中执行，而碰到异步任务就放到任务队列之中，等到执行栈执行完毕之后再去执行任务队列之中的事件

        // Javascript有一个main thread 主进程和call-stack（一个调用堆栈），在对一个调用堆栈中的task处理的时候，其他的都要等着。当在执行过程中遇到一些类似于setTimeout等异步操作的时候，会交给浏览器的其他模块(以webkit为例，是webcore模块)进行处理，当到达setTimeout指定的延时执行的时间之后，task(回调函数)会放入到任务队列之中。一般不同的异步任务的回调函数会放入不同的任务队列之中。等到调用栈中所有task执行完毕之后，接着去执行任务队列之中的task(回调函数)。

        for (var i = 0; i < 5; i++) {
            setTimeout(function() {
                console.log(new Date, i);
            }, 1000);
        }
        console.log(new Date, i);
        // 首先i=0时，满足条件，执行栈执行循环体里面的代码，发现是setTimeout，将其出栈之后把延时执行的函数交给Timer模块进行处理。

        // 当i=1,2,3,4时，均满足条件，情况和i=0时相同，因此timer模块里面有5个相同的延时执行的函数。

        // 当i=5的时候，不满足条件，因此for循环结束,console.log(new Date, i)入栈，此时的i已经变成了5。因此输出5。

        // 此时1s已经过去，timer模块将5个回调函数按照注册的顺序返回给任务队列。

        // 执行引擎去执行任务队列中的函数，5个function依次入栈执行之后再出栈，此时的i已经变成了5。因此几乎同时输出5个5。

        // 因此等待的1s的时间其实只有输出第一个5之后需要等待1s，这1s的时间是timer模块需要等到的规定的1s时间之后才将回调函数交给任务队列。等执行栈执行完毕之后再去执行任务对列中的5个回调函数。这期间是不需要等待1s的。因此输出的状态就是：5 -> 5,5,5,5,5，即第1个 5 直接输出，1s之后，输出 5个5；

        // 相当于每次遇到setTimeOut函数就扔到一边，最后循环几次就放几个setTimeOut函数进去，最会循环结束，其他同步函数也结束后，开始执行几个setTimeOut函数，它们基本就是同时执行，只看自己的回调时间

        
    </script>
</body>

</html>
