<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Websocket</title>
</head>
<body>

    <!-- script -->
    <script>
        // 前后端数据交互

        // HTTP协议是基于请求/响应模式的，因此只要服务端给了响应，本次HTTP连接就结束了，或者更准确的说，是本次HTTP请求就结束了
        // 所以HTTP不存在长连接短连接一说
        // TCP连接。TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才有真正的长连接和短连接这一说
        // HTTP请求和HTTP响应，都是通过TCP连接这个通道来回传输的

        // 短轮询，基本不使用
        // 利用前台的ajax不断向后台服务器请求，后台服务器不断查看数据库里的信息是否变化

        // 长轮询
        // 客户端的动作都是一样的，就是不停的去请求，不同的是服务端，短轮询情况下服务端每次请求不管有没有变化都会立即返回结果，
        // 而长轮询情况下，如果有变化才会立即返回结果，而没有变化的话，则不会再立即给客户端返回结果，直到超时为止

        // 长轮询和短轮询最大的区别是，短轮询去服务端查询的时候，不管数据库数据有没有变化，服务器就立即返回结果了。而长轮询则不是，
        // 在长轮询中，服务器如果检测到后台数据没有变化的话，将会把当前请求挂起一段时间（这个时间也叫作超时时间，一般是几十秒）。
        // 在这个时间里，服务器会去检测后台数据有没有变化，检测到变化就立即返回，否则就一直等到超时为止

        // 不管是长轮询还是短轮询，都不太适用于客户端数量太多的情况，因为每个服务器所能承载的TCP连接数是有上限的，
        // 这种轮询很容易把连接数顶满

        // 长短轮询和长短连接的区别：
        // 第一个区别是决定的方式，一个TCP连接是否为长连接，是通过设置HTTP的Connection Header来决定的，而且是需要两边都设置才有效。
        // 而一种轮询方式是否为长轮询，是根据服务端的处理方式来决定的，与客户端没有关系
        // 第二个区别就是实现的方式，连接的长短是通过协议来规定和实现的。而轮询的长短，是服务器通过编程的方式手动挂起请求来实现的

        // Comet，服务器向页面推送数据，实现方式有长轮询和流，必须前后端配合
        
        // SSE，服务器推送，是围绕只读Comet交互退出的API或者模式，SSE只能接受的MIME类型type/event-stream 类型，响应格式是纯文本
        // EventSourse(urL)，传入的URL必须与创建对象的页面同源
        // EventSourse属性，readyState：0表示正连接服务器，1表示打开了连接，2表示关闭了连接
        var source = new EventSourse('myEvents.php');
        // 支持三个事件：
        // open，在建立连接时触发
        // message，在从服务器接收新事件时触发
        // error，在无法建立连接时触发
        
        // WebSocket
        // 最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，
        // 属于服务器推送技术的一种
        // 其他特点包括：
        // （1）建立在 TCP 协议之上，服务器端的实现比较容易
        // （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，
        // 能通过各种 HTTP 代理服务器
        // （3）数据格式比较轻量，性能开销小，通信高效
        // （4）可以发送文本，也可以发送二进制数据
        // （5）没有同源限制，客户端可以与任意服务器通信
        // （6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL

        // WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例
        var ws = new WebSocket('ws://localhost:8080');
        // webSocket.readyState，readyState属性返回实例对象的当前状态，共有四种：
        // CONNECTING：值为0，表示正在连接
        // OPEN：值为1，表示连接成功，可以通信了
        // CLOSING：值为2，表示连接正在关闭
        // CLOSED：值为3，表示连接已经关闭，或者打开连接失败

        // webSocket.bufferedAmount，实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束

        // WebSocket事件：
        // webSocket.onopen，用于指定连接成功后的回调函数
        // webSocket.onclose，用于指定连接关闭后的回调函数
        // webSocket.onmessage，用于指定收到服务器数据后的回调函数，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）
        // webSocket.send()，用于向服务器发送数据
        // webSocket.onerror，用于指定报错时的回调函数


    </script>
</body>
</html>