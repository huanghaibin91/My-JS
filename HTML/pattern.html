<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>JavaScript Pattern</title>
</head>

<body>
    <!-- script -->
    <script>
        // 单例模式
        // 最简单的单例模式就是一个对象，但是对象的缺陷是可以在外部访问和修改对象的属性和方法
        // 使用闭包和立即执行函数生成单例模式

        // 策略模式的定义是： 定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换
        // 定义一系列的算法，把它们各自封装成策略类，算法被封装在策略类内部的方法里。在客户对 Context 发起请求的时候，
        //  Context 总是把请求委托给这些策略对象中间的某一个进行计算
        // 表单校验：
        var registerForm = document.getElementById('registerForm');
        registerForm.onsubmit = function () {
            if (registerForm.userName.value === '') {
                alert('用户名不能为空');
                return false;
            }
            if (registerForm.password.value.length < 6) {
                alert('密码长度不能少于 6 位');
                return false;
            }
            if (!/(^1[3|5|8][0-9]{9}$)/.test(registerForm.phoneNumber.value)) {
                alert('手机号码格式不正确');
                return false;
            }
        }
        // 以上代码缺点：
        // registerForm.onsubmit 函数比较庞大，包含了很多 if-else 语句，这些语句需要覆盖所有的校验规则。
        // registerForm.onsubmit 函数缺乏弹性，如果增加了一种新的校验规则，或者想把密码的长度校验从 6 改成 8，我们都必须深入 
        // registerForm.onsubmit 函数的内部实现，这是违反开放—封闭原则的。
        // 算法的复用性差，如果在程序中增加了另外一个表单，这个表单也需要进行一些类似的校验，那我们很可能将这些校验逻辑复制得漫天遍野

        // 策略模式改写
        // strategies里写所有的验证方法
        var strategies = {
            isNonEmpty: function (value, errorMsg) {
                if (value === '') {
                    return errorMsg;
                }
            },
            minLength: function (value, length, errorMsg) {
                if (value.length < length) {
                    return errorMsg;
                }
            },
            isMobile: function (value, errorMsg) {
                if (!/(^1[3|5|8][0-9]{9}$)/.test(value)) {
                    return errorMsg;
                }
            }
        };
        // 验证器类
        var Validator = function () {
            this.cache = [];
        };
        Validator.prototype.add = function (dom, rules) {
            var self = this;
            for (var i = 0, rule; rule = rules[i++];) {
                (function (rule) {
                    var strategyAry = rule.strategy.split(':');
                    var errorMsg = rule.errorMsg;
                    self.cache.push(function () {
                        var strategy = strategyAry.shift();
                        strategyAry.unshift(dom.value);
                        strategyAry.push(errorMsg);
                        return strategies[strategy].apply(dom, strategyAry);
                    });
                })(rule)
            }
        };
        Validator.prototype.start = function () {
            for (var i = 0, validatorFunc; validatorFunc = this.cache[i++];) {
                var errorMsg = validatorFunc();
                if (errorMsg) {
                    return errorMsg;
                }
            }
        };
        // 调用验证
        var registerForm = document.getElementById('registerForm');
        var validataFunc = function () {
            var validator = new Validator();
            validator.add(registerForm.userName, [{
                strategy: 'isNonEmpty',
                errorMsg: '用户名不能为空'
            }, {
                strategy: 'minLength:6',
                errorMsg: '用户名长度不能小于 10 位'
            }]);
            validator.add(registerForm.password, [{
                strategy: 'minLength:6',
                errorMsg: '密码长度不能小于 6 位'
            }]);
            validator.add(registerForm.phoneNumber, [{
                strategy: 'isMobile',
                errorMsg: '手机号码格式不正确'
            }]);
            var errorMsg = validator.start();
            return errorMsg;
        }
        registerForm.onsubmit = function () {
            var errorMsg = validataFunc();
            if (errorMsg) {
                alert(errorMsg);
                return false;
            }
        };
        // 策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。
        // 策略模式提供了对开放—封闭原则的完美支持，将算法封装在独立的 strategy 中，使得它们易于切换，易于理解，易于扩展。
        // 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作。
        // 在策略模式中利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻便的替代方案

        // 代理模式
        // 两种模式：保护代理，会过滤掉一些不符合条件的请求。虚拟代理，一些开销很大的对象，延迟到真正需要它的时候才去创建
        // 虚拟代理最常使用
        // 图片预加载，在图片没加载耗时用一张占位图代理

        // 不使用代理模式
        var MyImage = (function () {
            var imgNode = document.createElement('img');
            document.body.appendChild(imgNode);
            var img = new Image;
            img.onload = function () { // 当图片加载好后，更改图片链接指向实际加载的图片
                imgNode.src = img.src;
            };
            return {
                setSrc: function (src) {
                    imgNode.src = 'file:// /C:/Users/svenzeng/Desktop/loading.gif'; // 设置占位图片
                    img.src = src; // 设置实际加载图片
                }
            }
        })();
        MyImage.setSrc('http:// imgcache.qq.com/music/photo/k/000GGDys0yA0Nk.jpg');
        // 单一职责原则指的是，就一个类（通常也包括对象和函数等）而言，应该仅有一个引起它变化的原因

        // 使用虚拟代理模式
        // myImage设置图片链接
        var myImage = (function () {
            var imgNode = document.createElement('img');
            document.body.appendChild(imgNode);
            return {
                setSrc: function (src) {
                    imgNode.src = src;
                }
            }
        })();
        // 实现占位图片功能，这个功能不是必须的，所以和加载图片功能分离
        var proxyImage = (function () {
            var img = new Image;
            img.onload = function () {
                myImage.setSrc(this.src);
            }
            return {
                setSrc: function (src) {
                    myImage.setSrc('file:// /C:/Users/svenzeng/Desktop/loading.gif'); // 占位图片
                    img.src = src;
                }
            }
        })();
        proxyImage.setSrc('http:// imgcache.qq.com/music/photo/k/000GGDys0yA0Nk.jpg'); // 实际要加载的图片
        // 实际上，我们需要的只是给 img 节点设置 src，预加载图片只是一个锦上添花的功能。如果能把这个操作放在另一个对象里面，
        // 自然是一个非常好的方法。于是代理的作用在这里就体现出来了，代理负责预加载图片，预加载的操作完成之后，把请求重新交给本体 
        // MyImage
        // 代理和本体的接口保持一致性，上面都是serSrc接口，这样用户可以放心地请求代理，他只关心是否能得到想要的结果。在任何使
        // 用本体的地方都可以替换成使用代理
        // 虚拟代理合并HTTP请求
        // 例：点击将选项传回服务器，如果频繁点击就会一直上传HTTP请求，如果利用虚拟代理间隔一段时间将选择的集合上传，这样就可以减少
        // 频繁点击产生了多个HTTP请求
        var synchronousFile = function (id) { // 这里是实际的操作
            console.log('开始同步文件， id 为: ' + id);
        };
        var proxySynchronousFile = (function () {
            var cache = [], // 保存一段时间内需要同步的 ID
                timer; // 定时器
            return function (id) {
                cache.push(id);
                if (timer) { // 保证不会覆盖已经启动的定时器
                    return;
                }
                timer = setTimeout(function () {
                    synchronousFile(cache.join(',')); // 2 秒后向本体发送需要同步的 ID 集合
                    clearTimeout(timer); // 清空定时器
                    timer = null;
                    cache.length = 0; // 清空 ID 集合
                }, 2000);
            }
        })();
        var checkbox = document.getElementsByTagName('input');
        for (var i = 0, c; c = checkbox[i++];) { // 这种循环写法，直接在循环体内写单个循环的变量
            c.onclick = function () {
                if (this.checked === true) {
                    proxySynchronousFile(this.id);
                }
            }
        };
        // 缓存代理利用爱丽将之前的结果缓存起来，这样在下次进行同样的请求时，就可以调用缓存的内容，增加响应速度和避免二次运算
        // 适用场景：大型耗时的运算，Ajax请求

        // 迭代器模式
        // 迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示

        // 发布订阅模式
        // 发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知
        // 发布—订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案
        // 发布—订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。发布—订阅模式让两个对象
        // 松耦合地联系在一起

        // 最简单的发布订阅模式，DOM事件，只有当触发DOM上事件时，事件才会被触发
        // 登录功能
        $.ajax('http:// xxx.com?login', function (data) { // 登录成功
            login.trigger('loginSucc', data); // 发布登录成功的消息
        });
        var header = (function () { // header 模块
            login.listen('loginSucc', function (data) {
                header.setAvatar(data.avatar);
            });
            return {
                setAvatar: function (data) {
                    console.log('设置 header 模块的头像');
                }
            }
        })();
        var nav = (function () { // nav 模块
            login.listen('loginSucc', function (data) {
                nav.setAvatar(data.avatar);
            });
            return {
                setAvatar: function (avatar) {
                    console.log('设置 nav 模块的头像');
                }
            }
        })();
        // 全局发布-订阅对象
        // 发布—订阅模式可以用一个全局的 Event 对象来实现，订阅者不需要了解消息来自哪个发布者，发布者也不知道消息会推送给哪些订
        // 阅者， Event 作为一个类似“中介者”的角色，把订阅者和发布者联系起来
        var Event = (function () {
            var global = this,
                Event,
                _default = 'default';
            Event = function () {
                var _listen,
                    _trigger,
                    _remove,
                    _slice = Array.prototype.slice,
                    _shift = Array.prototype.shift,
                    _unshift = Array.prototype.unshift,
                    namespaceCache = {},
                    _create,
                    find,
                    each = function (ary, fn) {
                        var ret;
                        for (var i = 0, l = ary.length; i < l; i++) {
                            var n = ary[i];
                            ret = fn.call(n, i, n);
                        }
                        return ret;
                    };
                _listen = function (key, fn, cache) {
                    if (!cache[key]) {
                        cache[key] = [];
                    }
                    cache[key].push(fn);
                };
                _remove = function (key, cache, fn) {
                    if (cache[key]) {
                        if (fn) {
                            for (var i = cache[key].length; i >= 0; i--) {
                                if (cache[key][i] === fn) {
                                    cache[key].splice(i, 1);
                                }
                            }
                        } else {
                            cache[key] = [];
                        }
                    }
                };
                _trigger = function () {
                    var cache = _shift.call(arguments),
                        key = _shift.call(arguments),
                        args = arguments,
                        _self = this,
                        ret,
                        stack = cache[key];
                    if (!stack || !stack.length) {
                        return;
                    }
                    return each(stack, function () {
                        return this.apply(_self, args);
                    });
                };
                _create = function (namespace) {
                    var namespace = namespace || _default;
                    var cache = {},
                        offlineStack = [], // 离线事件
                        ret = {
                            listen: function (key, fn, last) {
                                _listen(key, fn, cache);
                                if (offlineStack === null) {
                                    return;
                                }
                                if (last === 'last') {
                                    offlineStack.length && offlineStack.pop()();
                                } else {
                                    each(offlineStack, function () {
                                        this();
                                    });
                                }
                                offlineStack = null;
                            },
                            one: function (key, fn, last) {
                                _remove(key, cache);
                                this.listen(key, fn, last);
                            },
                            remove: function (key, fn) {
                                _remove(key, cache, fn);
                            },
                            trigger: function () {
                                var fn,
                                    args,
                                    _self = this;
                                _unshift.call(arguments, cache);
                                args = arguments;
                                fn = function () {
                                    return _trigger.apply(_self, args);
                                };
                                if (offlineStack) {
                                    return offlineStack.push(fn);
                                }
                                return fn();
                            }
                        };
                    return namespace ?
                        (namespaceCache[namespace] ? namespaceCache[namespace] :
                            namespaceCache[namespace] = ret) :
                        ret;
                };
                return {
                    create: _create,
                    one: function (key, fn, last) {
                        var event = this.create();
                        event.one(key, fn, last);
                    },
                    remove: function (key, fn) {
                        var event = this.create();
                        event.remove(key, fn);
                    },
                    listen: function (key, fn, last) {
                        var event = this.create();
                        event.listen(key, fn, last);
                    },
                    trigger: function () {
                        var event = this.create();
                        event.trigger.apply(this, arguments);
                    }
                };
            }();
            return Event;
        })();

        // 命令模式
        // 命令模式中的命令（command）指的是一个执行某些特定事情的指令
        // 有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么，此时希望用一种松耦合的方式来
        // 设计软件，使得请求发送者和请求接收者能够消除彼此之间的耦合关系

        // 组合模式
        // 适用场景：表示对象的部分-整体层次结构。组合模式可以方便地构造一棵树来表示对象的部分-整体结构和客户希望统一对待树中的所有对象

        // 模板模式
        // 模板方法模式是一种只需使用继承就可以实现的非常简单的模式，提取公共部分生成公共类，其它的以继承公共类模板并添加自己特有的
        // 方法与属性

        // 享元模式
        // 享元（flyweight）模式是一种用于性能优化的模式，“ fly”在这里是苍蝇的意思，意为蝇量级。享元模式的核心是运用共享技术来有
        // 效支持大量细粒度的对象
        // 享元模式要求将对象的属性划分为内部状态与外部状态（状态在这里通常指属性），享元模式的目标是尽量减少共享对象的数量
        // 划分内部状态与外部状态：
        // 内部状态存储于对象内部
        // 内部状态可以被一些对象共享
        // 内部状态独立于具体的场景，通常不会改变
        // 外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享
        // 适用享元模式场景：
        // 一个程序中使用了大量的相似对象
        // 由于使用了大量对象，造成很大的内存开销
        // 对象的大多数状态都可以变为外部状态
        // 剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象

        // 职责链模式
        // 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，
        // 直到有一个对象处理它为止

        // 中介者模式
        // 中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是
        // 互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可

        // 装饰者模式
        // 装饰者模式可以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象

        // 状态模式

        // 适配器模式
        // 配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体
        // 起工作
        // 比如JS事件处理，写一个兼容几种版本的事件处理程序，这样同一个名字就可以适配多个情况

        // 设计模式原则
        // 单一职责原则：一个对象（方法）只做一件事情
        // 最少知识原则：（LKP）说的是一个软件实体应当尽可能少地与其他实体发生相互作用
        // 开放-封闭原则：软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改
        // 接口和面向接口编程



    </script>
</body>

</html>