<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>this</title>
</head>

<body>
    <script type="text/javascript">
        function identify() {
            return this.name.toUpperCase();
        }
        function speak() {
            var greeting = "Hello, I'm " + identify.call(this); // call会改变this指向
            console.log(greeting);
        }
        var me = {
            name: "Kyle"
        };
        var you = {
            name: "Reader"
        };
        identify.call(me); // KYLE
        identify.call(you); // READER
        speak.call(me); // Hello, 我是 KYLE
        speak.call(you); // Hello, 我是 READER
        // this 的绑定和函数声明的位置没有任何关系， 只取决于函数的调用方式。
        // this 实际上是在函数被调用时发生的绑定， 它指向什么完全取决于函数在哪里被调用。
        // 调用位置： 调用位置就是函数在代码中被调用的位置（ 而不是声明的位置）。

        function baz() {
            // 当前调用栈是： baz
            // 因此， 当前调用位置是全局作用域
            console.log("baz");
            bar(); // <-- bar 的调用位置，baz中调用
        }

        function bar() {
            // 当前调用栈是 baz -> bar
            // 因此， 当前调用位置在 baz 中
            console.log("bar");
            foo(); // <-- foo 的调用位置，在baz中的bar中调用
        }

        function foo() {
            // 当前调用栈是 baz -> bar -> foo
            // 因此， 当前调用位置在 bar 中
            console.log("foo");
        }
        baz(); // <-- baz 的调用位置,全局作用域调用

        // 最常用的函数调用类型： 独立函数调用。 可以把这条规则看作是无法应用其他规则时的默认规则。
        // 严格模式，this指向undefined，非严格指向全局对象
        function foo2() {
            console.log(this.a);
        }
        var a = 2;
        foo2(); // 2，函数调用时应用了 this 的默认绑定， 因此 this 指向全局对象。

        var obj3 = {
            a: 1,
            b: this.a + 1, // 3，此时的this.a是全局的，因为{}不能形成作用域，所以this指的还是window（JS只有函数作用域）
            c: function () {
                console.log(this.a + 2);
            }
        }
        console.log(obj3.b);
        obj3.c();

        // 隐式绑定，规则是调用位置是否有上下文对象， 或者说是否被某个对象拥有或者包含
        // 对象属性引用链中只有最顶层或者说最后一层会影响调用位置。
        function foo3() {
            console.log(this.a);
        }
        var obj2 = {
            a: 42,
            foo2: foo3
        };
        var obj1 = {
            a: 2,
            obj1: obj2
        };
        obj1.obj1.foo2(); // 42

        // 隐式丢失，this 绑定问题就是被隐式绑定的函数会丢失绑定对象， 也就是说它会应用默认绑定， 
        // 从而把 this 绑定到全局对象或者 undefined 上
        function foo4() {
            console.log(this.a);
        }
        var obj4 = {
            a4: 2,
            foo4: foo4
        };
        var bar4 = obj4.foo4; // 函数别名！， bar 是 obj.foo 的一个引用， 但是实际上， 它引用的是 foo 函数本身， 
        // 因此此时的bar() 其实是一个不带任何修饰的函数调用， 因此应用了默认绑定。
        // 将函数作为值传递都会导致this应用默认绑定
        var a4 = "oops, global"; // a 是全局对象的属性
        bar4(); // "oops, global"

        function doFoo(fn) {
            // fn 其实引用的是 foo
            fn(); // <-- 调用位置！
        }
        doFoo(obj4.foo4); // "oops, global"

        // 显式绑定，使用函数的 call(..) 和apply(..) 方法。
        // call、apply方法的参数，应该是一个对象，apply第二个参数是数组，call是逗号分隔的参数。如果参数为空、
        // null和undefined，则默认传入全局对象
        function foo5() {
            console.log(this.a);
        }
        var obj5 = {
            a: 2
        };
        foo5.call(obj5); // 2，通过 foo.call(..)， 我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。
        // 硬绑定的 bar 不可能再修改它的 this

        // 简单的辅助绑定函数，ES5 中提供了内置的方法 Function.prototype.bind
        function bind(fn, obj) { // 将fn绑定到obj中，this指向obj
            return function() {
                return fn.apply(obj, arguments);
            };
        }

        // apply()和call()，传入null/undefined的时候将执行js全局对象浏览器中是window，其他环境是global 
        // 传入了一个原始值（ 字符串类型、 布尔类型或者数字类型） 来当作 this 的绑定对象， 这个原始值会被转换成它的对象形式
        // （ 也就是 new String(..)、 new Boolean(..) 或者new Number(..)）
        // bind与call、apply的区别是，bind会生成一个新函数，而call、apply会立即执行函数

        // 使用 new 来调用函数， 或者说发生构造函数调用时， 会自动执行下面的操作。
        // 1. 创建（ 或者说构造） 一个全新的对象。
        // 2. 这个新对象会被执行 [[ 原型 ]] 连接。
        // 3. 这个新对象会绑定到函数调用的 this。
        // 4. 如果函数没有返回其他对象， 那么 new 表达式中的函数调用会自动返回这个新对象。

        // 以根据优先级来判断函数在某个调用位置应用的是哪条规则。 可以按照下面的顺序来进行判断：
        // 1. 函数是否在 new 中调用（ new 绑定） ？ 如果是的话 this 绑定的是新创建的对象。var bar = new foo()
        // 2. 函数是否通过 call、 apply（ 显式绑定） 或者硬绑定调用？ 如果是的话， this 绑定的是指定的对象。var bar = foo.call(obj2)
        // 3. 函数是否在某个上下文对象中调用（ 隐式绑定） ？ 如果是的话， this 绑定的是那个上下文对象。var bar = obj1.foo()
        // 4. 如果都不是的话， 使用默认绑定。 如果在严格模式下， 就绑定到 undefined， 否则绑定到全局对象。var bar = foo()

        // 绑定例外
        // 如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、 apply 或者 bind， 这些值在调用时会被忽略， 实际应用的是默认绑定规则：
        function foo6() {
            console.log(this.a);
        }
        var a6 = 2;
        foo6.call(null); // 2

        function foo7(a, b) {
            console.log("a:" + a + ", b:" + b);
        }
        // 把数组“ 展开” 成参数
        foo7.apply(null, [2, 3]); // a:2, b:3
        // 使用 bind(..) 进行柯里化
        var bar7 = foo7.bind(null, 2);
        bar7(3); // a:2, b:3

        // 箭头函数并不是使用 function 关键字定义的， 而是使用被称为“ 胖箭头” 的操作符 => 定义的。 箭头函数不使用 this 
        // 的四种标准规则， 而是根据外层（ 函数或者全局） 作用域来决定 this。
        function foo8() {
            // 返回一个箭头函数
            return (a) => {
                //this 继承自 foo()
                console.log(this.a);
            };
        }
        var obj8 = {
            a: 2
        };
        var obj9 = {
            a: 3
        };
        var bar8 = foo8.call(obj8);
        bar8.call(obj9); // 2, 不是 3 ！foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。 由于 foo() 的 this 
        // 绑定到 obj1，bar（ 引用箭头函数） 的 this 也会绑定到 obj1， 箭头函数的绑定无法被修改。（ new 也不行！ ）

        function foo9() {
            setTimeout(() => {
                // 这里的 this 在此法上继承自 foo9()
                console.log(this.a);
            }, 100);
        }
        var obj10 = {
            a: 2
        };
        foo9.call(obj10); // 2

        function foo10() {
            var self = this; // 将this，赋值给self，就会保存this的引用
            setTimeout(function() {
                console.log(self.a);
            }, 100);
        }
        var obj11 = {
            a: 2
        };
        foo10.call(obj11); // 2,这是传统方法

        // 当在对象方法中再定义函数，这时候this又绑定window
        var name = 'me';
        var person = {
            name: 'you',
            sayName: function () {
                function fn () {
                    console.log(this);
                    console.log(this.name);
                }
                fn();
            }
        }
        person.sayName();

        var name2 = 'me';
        var person2 = {
            name: 'you',
            sayName: function () {
                // 用that保存下this的值
                var that = this;
                function fn () {
                    console.log(that);
                    console.log(that.name);
                }
                fn();
            }
        }
        person2.sayName();

        // setTimeOut中的回调函数中的this默认指向window对象，相当于将函数作为值传递到setTimeOut中，此时采用默认绑定

        // 在构造函数的prototype中的this指向当前对象，其实就是采用new判定


    </script>
</body>

</html>
