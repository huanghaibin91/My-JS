<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>循环</title>
</head>

<body>
    <img src="./image/loop1.jpg" alt="">
    <p>单线程红色为等待时间</p>
    <img src="./image/loop2.png" alt="">
    <p>程序中设置两个线程：一个负责程序本身的运行，称为"主线程"；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，
        被称为"Event Loop线程"（可以译为"消息线程"）。上图主线程的绿色部分，还是表示运行时间，而橙色部分表示空闲时间。
        每当遇到I/O的时候，主线程就让Event Loop线程去通知相应的I/O程序，然后接着往后运行，所以不存在红色的等待时间。
        等到I/O程序完成操作，Event Loop线程再把结果返回主线程。主线程就调用事先设定的回调函数，完成整个任务称为"异步模式"
        （asynchronous I/O）或"非堵塞模式"（non-blocking mode）</p>
    <img src="./image/loop3.png" alt="">
    <script type="text/javascript">
        // Javascript的事件分为同步任务和异步任务，遇到同步任务就放在执行栈中执行，而碰到异步任务就放到任务队列之中，
        // 等到执行栈执行完毕之后再去执行任务队列之中的事件

        // Javascript有一个main thread 主进程和call-stack（一个调用堆栈），在对一个调用堆栈中的task处理的时候，
        // 其他的都要等着。当在执行过程中遇到一些类似于setTimeout等异步操作的时候，会交给浏览器的其他模块(以webkit为例，
        // 是webcore模块)进行处理，当到达setTimeout指定的延时执行的时间之后，task(回调函数)会放入到任务队列之中。
        // 一般不同的异步任务的回调函数会放入不同的任务队列之中。等到调用栈中所有task执行完毕之后，接着去执行任务队列之中的
        // task(回调函数)。

        for (var i = 0; i < 5; i++) {
            setTimeout(function() {
                console.log(new Date, i);
            }, 1000);
        }
        console.log(new Date, i);
        // 首先i=0时，满足条件，执行栈执行循环体里面的代码，发现是setTimeout，将其出栈之后把延时执行的函数交给
        // Timer模块进行处理。

        // 当i=1,2,3,4时，均满足条件，情况和i=0时相同，因此timer模块里面有5个相同的延时执行的函数。

        // 当i=5的时候，不满足条件，因此for循环结束,console.log(new Date, i)入栈，此时的i已经变成了5。因此输出5。

        // 此时1s已经过去，timer模块将5个回调函数按照注册的顺序返回给任务队列。

        // 执行引擎去执行任务队列中的函数，5个function依次入栈执行之后再出栈，此时的i已经变成了5。因此几乎同时输出5个5。

        // 因此等待的1s的时间其实只有输出第一个5之后需要等待1s，这1s的时间是timer模块需要等到的规定的1s时间之后才将
        // 回调函数交给任务队列。等执行栈执行完毕之后再去执行任务对列中的5个回调函数。这期间是不需要等待1s的。
        // 因此输出的状态就是：5 -> 5,5,5,5,5，即第1个 5 直接输出，1s之后，输出 5个5；

        // 相当于每次遇到setTimeOut函数就扔到一边，最后循环几次就放几个setTimeOut函数进去，最会循环结束，
        // 其他同步函数也结束后，开始执行几个setTimeOut函数，它们基本就是同时执行，只看自己的回调时间

        // break，立即退出循环。continue，立即退出循环，再从退出位置后面继续执行。两者都可以和label语句联合使用，
        // 从而返回代码中特定的位置

        var num = 0;
        outermost:
        for (var i = 0; i < 10; i++) {
            for (var j = 0; j < 10; j++) {
                if (i == 5 && j ==5) {
                    // break; // 仅退出j循环，num=95
                    // continue; // 仅退出i==5&&j==5这一次循环，num=99
                    // break outermost; // 退出ij两个循环，num=55
                    continue outermost; // 退出j循环，继续i循环，num=95
                }
                num++;
            }
        }
        console.log(num);

    </script>
</body>

</html>
